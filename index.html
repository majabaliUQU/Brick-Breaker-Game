<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    
    <!-- Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª ØªØ·Ø¨ÙŠÙ‚ Ø§Ù„ÙˆÙŠØ¨ (PWA) -->
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="ÙƒØ³Ø± Ø§Ù„Ø·ÙˆØ¨">
    <meta name="application-name" content="ÙƒØ³Ø± Ø§Ù„Ø·ÙˆØ¨">
    <meta name="theme-color" content="#1a1a2e">

    <!-- Ø£ÙŠÙ‚ÙˆÙ†Ø© Ø§Ù„ØªØ·Ø¨ÙŠÙ‚ (Ù…Ø¯Ù…Ø¬Ø© Ù„ØªØ¹Ù…Ù„ Ø¨Ø¯ÙˆÙ† Ù…Ù„ÙØ§Øª Ø®Ø§Ø±Ø¬ÙŠØ©) -->
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100' style='background:%2316213e;border-radius:20px'><text y='.9em' font-size='90' x='50%25' text-anchor='middle'>ğŸ§±</text></svg>">
    <link rel="apple-touch-icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100' style='background:%2316213e'><text y='.9em' font-size='90' x='50%25' text-anchor='middle'>ğŸ§±</text></svg>">

    <!-- ØªØ­Ø³ÙŠÙ†Ø§Øª Ø§Ù„Ø¸Ù‡ÙˆØ± ÙÙŠ Ø§Ù„Ø´Ø¨ÙƒØ§Øª Ø§Ù„Ø§Ø¬ØªÙ…Ø§Ø¹ÙŠØ© (ÙˆØ§ØªØ³Ø§Ø¨ØŒ ØªÙˆÙŠØªØ±ØŒ ÙÙŠØ³Ø¨ÙˆÙƒ) -->
    <meta property="og:title" content="ØªØ­Ø¯ÙŠ ÙƒØ³Ø± Ø§Ù„Ø·ÙˆØ¨ ğŸ”¥">
    <meta property="og:description" content="Ù‡Ù„ ÙŠÙ…ÙƒÙ†Ùƒ Ø§Ù„ÙˆØµÙˆÙ„ Ù„Ù„Ù…Ø³ØªÙˆÙŠØ§Øª Ø§Ù„Ù…ØªÙ‚Ø¯Ù…Ø©ØŸ Ù„Ø¹Ø¨Ø© Ø­Ù…Ø§Ø³ÙŠØ© Ø¨ÙƒØ±Ø§Øª Ù†Ø§Ø±ÙŠØ© ÙˆÙ…ØªØ¹Ø¯Ø¯Ø©. Ø¬Ø±Ø¨Ù‡Ø§ Ø§Ù„Ø¢Ù†!">
    <meta property="og:type" content="website">
    <!-- ØµÙˆØ±Ø© Ø§ÙØªØ±Ø§Ø¶ÙŠØ© Ø¬Ø°Ø§Ø¨Ø© Ù„Ù„Ù…Ø´Ø§Ø±ÙƒØ© -->
    <meta property="og:image" content="https://images.unsplash.com/photo-1550745165-9bc0b252726f?auto=format&fit=crop&w=1200&q=80">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="ØªØ­Ø¯ÙŠ ÙƒØ³Ø± Ø§Ù„Ø·ÙˆØ¨ ğŸ”¥">
    <meta name="twitter:description" content="Ø§ÙƒØ³Ø± Ø§Ù„Ø·ÙˆØ¨ØŒ Ø§Ø¬Ù…Ø¹ Ø§Ù„ÙƒØ±Ø§ØªØŒ ÙˆØ­Ù‚Ù‚ Ø£Ø¹Ù„Ù‰ Ø§Ù„Ù†ØªØ§Ø¦Ø¬!">
    <meta name="twitter:image" content="https://images.unsplash.com/photo-1550745165-9bc0b252726f?auto=format&fit=crop&w=1200&q=80">

    <title>Ù„Ø¹Ø¨Ø© ÙƒØ³Ø± Ø§Ù„Ø·ÙˆØ¨</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Tajawal:wght@400;700&display=swap');

        html, body {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: #1a1a2e;
            color: white;
            font-family: 'Tajawal', sans-serif;
            touch-action: none;
            position: fixed;
        }

        #gameContainer {
            position: relative;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            background: #16213e;
        }

        canvas {
            display: block;
            background-color: #0f3460;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
        }

        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 5;
        }

        .score-board {
            position: absolute;
            top: 10px;
            left: 0;
            width: 100%;
            display: flex;
            justify-content: space-between;
            padding: 0 20px;
            box-sizing: border-box;
            font-size: 20px;
            font-weight: bold;
            text-shadow: 2px 2px 4px #000;
        }

        #menu {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.95);
            padding: 25px;
            border-radius: 15px;
            text-align: center;
            pointer-events: auto;
            border: 2px solid #e94560;
            min-width: 280px;
            z-index: 20;
            max-width: 90%;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
        }

        h1 { margin: 0 0 10px 0; color: #e94560; }
        p { margin: 5px 0 20px 0; font-size: 15px; color: #ccc; line-height: 1.6; }

        .btn-group {
            display: flex;
            flex-direction: column;
            gap: 10px;
            justify-content: center;
            align-items: center;
        }

        button {
            color: white;
            border: none;
            padding: 12px 30px;
            font-size: 18px;
            border-radius: 8px;
            cursor: pointer;
            font-family: 'Tajawal', sans-serif;
            width: 100%;
            transition: transform 0.1s, opacity 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }
        
        button:active { transform: scale(0.96); }

        .btn-primary { background: #e94560; font-weight: bold; }
        .btn-fullscreen { background: #0f3460; border: 1px solid #e94560; }
        
        /* Ø²Ø± Ø§Ù„Ù…Ø´Ø§Ø±ÙƒØ© Ø§Ù„Ø¬Ø¯ÙŠØ¯ */
        .btn-share { 
            background: #25D366; /* Ù„ÙˆÙ† ÙˆØ§ØªØ³Ø§Ø¨ ØªÙ‚Ø±ÙŠØ¨Ø§Ù‹ */
            color: white;
            font-weight: bold;
        }

        .hidden { display: none !important; }
        #menu.success-theme { border-color: #2ecc71 !important; }
        #menu.success-theme h1 { color: #2ecc71 !important; }
        #menu.success-theme .btn-primary { background: #2ecc71 !important; }

        .message-popup {
            position: absolute;
            top: 30%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 24px;
            font-weight: bold;
            text-shadow: 0 0 10px #000;
            opacity: 0;
            transition: opacity 0.5s;
            pointer-events: none;
            width: 100%;
            text-align: center;
            z-index: 15;
        }
        
        .score-float {
            position: absolute;
            font-weight: bold;
            font-size: 24px;
            pointer-events: none;
            animation: floatUp 1s ease-out forwards;
            z-index: 10;
        }

        @keyframes floatUp {
            0% { transform: translateY(0); opacity: 1; }
            100% { transform: translateY(-50px); opacity: 0; }
        }
        
        /* Ø±Ø³Ø§Ù„Ø© Ù†Ø³Ø® Ø§Ù„Ø±Ø§Ø¨Ø· */
        #toast {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.8);
            color: white;
            padding: 10px 20px;
            border-radius: 20px;
            font-size: 14px;
            opacity: 0;
            transition: opacity 0.3s;
            pointer-events: none;
            z-index: 100;
        }
    </style>
</head>
<body>

    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>
        <div id="fireMessage" class="message-popup" style="color: #f39c12; text-shadow: 0 0 10px red;">ğŸ”¥ ÙƒØ±Ø© Ù†Ø§Ø±ÙŠØ©! ğŸ”¥</div>
        <div id="multiMessage" class="message-popup" style="color: #00FFFF; text-shadow: 0 0 10px blue; top: 40%;">âš½ ÙƒØ±Ø© Ø¥Ø¶Ø§ÙÙŠØ©! âš½</div>
        <div id="toast">ØªÙ… Ù†Ø³Ø® Ø±Ø§Ø¨Ø· Ø§Ù„Ù„Ø¹Ø¨Ø©!</div>
        
        <div id="ui-layer">
            <div class="score-board">
                <span id="scoreText">Ø§Ù„Ù†Ù‚Ø§Ø·: 0</span>
                <span id="levelText">Ø§Ù„Ù…Ø³ØªÙˆÙ‰: 1</span>
            </div>
        </div>

        <div id="menu">
            <h1 id="menuTitle">Ù„Ø¹Ø¨Ø© ÙƒØ³Ø± Ø§Ù„Ø·ÙˆØ¨</h1>
            <p id="menuDesc">
                <span style="color:#e94560; font-weight:bold">Ø§Ù„Ù‚ÙˆØ§Ø¹Ø¯:</span><br>
                1. ÙƒØ³Ø± Ø·ÙˆØ¨Ø© ÙˆØ§Ø­Ø¯Ø© = <span style="color:red">-1 Ù†Ù‚Ø·Ø©</span><br>
                2. ÙƒØ³Ø± 2+ Ø·ÙˆØ¨Ø© = <span style="color:#2ecc71">Ù†Ù‚Ø§Ø· Ù…Ø¶Ø§Ø¹ÙØ©</span><br>
                3. Ø§Ù„Ø·ÙˆØ¨ Ø§Ù„Ø°Ù‡Ø¨ÙŠ ğŸ”¥ | Ø§Ù„Ø³Ù…Ø§ÙˆÙŠ âš½
            </p>
            <div class="btn-group">
                <button class="btn-primary" id="startBtn" onclick="handleMenuClick()">
                    <span>â–¶ï¸</span> Ø§Ø¨Ø¯Ø£ Ø§Ù„Ù„Ø¹Ø¨
                </button>
                <button class="btn-share" onclick="shareGame()">
                    <span>ğŸ”—</span> Ù…Ø´Ø§Ø±ÙƒØ© Ø§Ù„Ù„Ø¹Ø¨Ø©
                </button>
                <button class="btn-fullscreen" id="fullscreenBtn" onclick="toggleFullScreen()">
                    <span>â›¶</span> Ù…Ù„Ø¡ Ø§Ù„Ø´Ø§Ø´Ø©
                </button>
            </div>
        </div>
    </div>

<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const menu = document.getElementById('menu');
    const menuTitle = document.getElementById('menuTitle');
    const menuDesc = document.getElementById('menuDesc');
    const startBtn = document.getElementById('startBtn');
    const fullscreenBtn = document.getElementById('fullscreenBtn');
    const scoreText = document.getElementById('scoreText');
    const levelText = document.getElementById('levelText');
    const fireMessage = document.getElementById('fireMessage');
    const multiMessage = document.getElementById('multiMessage');
    const toast = document.getElementById('toast');

    // Ù…ØªØºÙŠØ±Ø§Øª Ø§Ù„Ù„Ø¹Ø¨Ø©
    let animationId;
    let score = 0;
    let level = 1;
    let isGameOver = false;
    let isLevelComplete = false;
    let isRunning = false;
    let balls = [];
    let bricks = [];

    const BOTTOM_OFFSET = 60; 

    const paddle = {
        width: 100,
        height: 15,
        x: 0,
        color: '#00adb5',
        speed: 8
    };

    const brickProps = {
        rowCount: 5,
        columnCount: 5,
        padding: 30,
        offsetTop: 60,
        height: 25,
        colors: ['#f39c12', '#e74c3c', '#9b59b6', '#3498db', '#2ecc71']
    };

    // === Ø¯Ø§Ù„Ø© Ø§Ù„Ù…Ø´Ø§Ø±ÙƒØ© Ø§Ù„Ø°ÙƒÙŠØ© ===
    async function shareGame() {
        const shareData = {
            title: 'Ù„Ø¹Ø¨Ø© ÙƒØ³Ø± Ø§Ù„Ø·ÙˆØ¨',
            text: 'ØªØ­Ø¯Ø§Ùƒ ØªÙƒØ³Ø± Ø±Ù‚Ù…ÙŠ Ø§Ù„Ù‚ÙŠØ§Ø³ÙŠ ÙÙŠ Ù‡Ø°Ù‡ Ø§Ù„Ù„Ø¹Ø¨Ø© Ø§Ù„Ø±Ù‡ÙŠØ¨Ø©! ğŸ”¥âš½',
            url: window.location.href
        };

        // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù…Ø§ Ø¥Ø°Ø§ ÙƒØ§Ù† Ø§Ù„Ù…ØªØµÙØ­ ÙŠØ¯Ø¹Ù… Ø§Ù„Ù…Ø´Ø§Ø±ÙƒØ© Ø§Ù„Ø£ØµÙ„ÙŠØ© (Ù„Ù„Ù…ÙˆØ¨Ø§ÙŠÙ„)
        if (navigator.share) {
            try {
                await navigator.share(shareData);
            } catch (err) {
                console.log('Error sharing:', err);
            }
        } else {
            // Ù†Ø³Ø®Ø© Ø§Ø­ØªÙŠØ§Ø·ÙŠØ© Ù„Ù„ÙƒÙ…Ø¨ÙŠÙˆØªØ±: Ù†Ø³Ø® Ø§Ù„Ø±Ø§Ø¨Ø· Ù„Ù„Ø­Ø§ÙØ¸Ø©
            try {
                await navigator.clipboard.writeText(window.location.href);
                showToast();
            } catch (err) {
                // Ø­Ù„ Ø¨Ø¯ÙŠÙ„ Ù„Ù„Ù…ØªØµÙØ­Ø§Øª Ø§Ù„Ù‚Ø¯ÙŠÙ…Ø© Ø£Ùˆ ØºÙŠØ± Ø§Ù„Ø¢Ù…Ù†Ø©
                const textArea = document.createElement("textarea");
                textArea.value = window.location.href;
                document.body.appendChild(textArea);
                textArea.select();
                document.execCommand("Copy");
                textArea.remove();
                showToast();
            }
        }
    }

    function showToast() {
        toast.style.opacity = 1;
        setTimeout(() => { toast.style.opacity = 0; }, 3000);
    }

    // === Ø§Ù„Ø¯Ø§Ù„Ø© Ø§Ù„Ø§Ø­ØªØ±Ø§ÙÙŠØ© Ù„Ù…Ù„Ø¡ Ø§Ù„Ø´Ø§Ø´Ø© ===
    function toggleFullScreen() {
        const doc = window.document;
        const docEl = doc.documentElement;
        const requestFullScreen = docEl.requestFullscreen || docEl.mozRequestFullScreen || docEl.webkitRequestFullScreen || docEl.msRequestFullscreen;
        const cancelFullScreen = doc.exitFullscreen || doc.mozCancelFullScreen || doc.webkitExitFullscreen || doc.msExitFullscreen;

        if (!doc.fullscreenElement && !doc.mozFullScreenElement && !doc.webkitFullscreenElement && !doc.msFullscreenElement) {
            if (requestFullScreen) {
                requestFullScreen.call(docEl).catch(err => {
                    showIphoneInstruction();
                });
            } else {
                showIphoneInstruction();
            }
        } else {
            if (cancelFullScreen) {
                cancelFullScreen.call(doc);
            }
        }
    }

    function showIphoneInstruction() {
        alert("Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠ Ø§Ù„Ø¢ÙŠÙÙˆÙ† (iOS):\n\nØªÙ…Ù†Ø¹ Apple Ø§Ù„Ù…ÙˆØ§Ù‚Ø¹ Ù…Ù† ØªÙØ¹ÙŠÙ„ Ù…Ù„Ø¡ Ø§Ù„Ø´Ø§Ø´Ø© ØªÙ„Ù‚Ø§Ø¦ÙŠØ§Ù‹.\n\nÙ„Ø¥Ø®ÙØ§Ø¡ Ø§Ù„Ø£Ø´Ø±Ø·Ø© ØªÙ…Ø§Ù…Ø§Ù‹ ÙˆØ§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ ØªØ¬Ø±Ø¨Ø© Ø§Ù„ØªØ·Ø¨ÙŠÙ‚:\n1. Ø§Ø¶ØºØ· Ø²Ø± Ø§Ù„Ù…Ø´Ø§Ø±ÙƒØ© (Ø³Ù‡Ù… Ù„Ù„Ø£Ø¹Ù„Ù‰) ÙÙŠ Ø£Ø³ÙÙ„ Ø§Ù„Ù…ØªØµÙØ­.\n2. Ø§Ø®ØªØ± 'Ø¥Ø¶Ø§ÙØ© Ø¥Ù„Ù‰ Ø§Ù„Ø´Ø§Ø´Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©' (Add to Home Screen).\n3. Ø§ÙØªØ­ Ø§Ù„Ù„Ø¹Ø¨Ø© Ù…Ù† Ø§Ù„Ø£ÙŠÙ‚ÙˆÙ†Ø© Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø©.");
    }

    function checkStandaloneMode() {
        const isStandalone = ('standalone' in window.navigator) && (window.navigator.standalone);
        const isDisplayModeStandalone = window.matchMedia('(display-mode: standalone)').matches;

        if (isStandalone || isDisplayModeStandalone) {
            if(fullscreenBtn) fullscreenBtn.style.display = 'none';
        }
    }

    function createBall(x, y, dx, dy, speed) {
        return {
            x: x, y: y, dx: dx, dy: dy, radius: 8, speed: speed,
            color: '#e94560', isFire: false, turnHits: []
        };
    }

    function resizeCanvas() {
        const maxWidth = 600;
        let width = window.innerWidth;
        let height = window.innerHeight;

        if (width > maxWidth) {
            width = maxWidth;
            if (height > 900) height = 900; 
        }

        canvas.width = width;
        canvas.height = height;

        if (!isRunning && !isLevelComplete) {
            initBricks(false);
            if(balls.length > 0) balls.forEach(drawBall);
            drawBricks();
            drawPaddle();
        } else if (isLevelComplete) {
            drawBricks();
            drawPaddle();
        }
    }

    function initBricks(reset = true) {
        let currentPadding = 34 - (level * 4);
        if (currentPadding < 5) currentPadding = 5;
        brickProps.padding = currentPadding;

        if (reset) {
            bricks = [];
            brickProps.rowCount = 5 + (level - 1);
        }
        
        const brickWidth = (canvas.width - (brickProps.padding * 2)) / brickProps.columnCount - brickProps.padding;
        brickProps.width = brickWidth;

        if (reset) {
            for (let c = 0; c < brickProps.columnCount; c++) {
                bricks[c] = [];
            }
            for (let r = 0; r < brickProps.rowCount; r++) {
                for (let c = 0; c < brickProps.columnCount; c++) {
                    createBrickAt(c, r);
                }
            }
        }
    }

    function createBrickAt(c, r) {
        const rand = Math.random();
        let isFire = false, isMulti = false;
        let color = brickProps.colors[r % brickProps.colors.length];

        if (rand < 0.1) { isFire = true; color = '#FFD700'; }
        else if (rand < 0.2) { isMulti = true; color = '#00FFFF'; }

        bricks[c][r] = { x: 0, y: 0, status: 1, color: color, isFire: isFire, isMulti: isMulti };
    }

    // Ø§Ù„ØªØ­ÙƒÙ…
    let rightPressed = false;
    let leftPressed = false;

    document.addEventListener('keydown', keyDownHandler);
    document.addEventListener('keyup', keyUpHandler);
    
    canvas.addEventListener('touchmove', touchMoveHandler, {passive: false});
    canvas.addEventListener('touchstart', touchMoveHandler, {passive: false});

    function keyDownHandler(e) {
        if (e.key === 'Right' || e.key === 'ArrowRight') rightPressed = true;
        else if (e.key === 'Left' || e.key === 'ArrowLeft') leftPressed = true;
    }
    function keyUpHandler(e) {
        if (e.key === 'Right' || e.key === 'ArrowRight') rightPressed = false;
        else if (e.key === 'Left' || e.key === 'ArrowLeft') leftPressed = false;
    }
    
    function touchMoveHandler(e) {
        e.preventDefault();
        const touch = e.touches[0];
        const rect = canvas.getBoundingClientRect();
        const relativeX = touch.clientX - rect.left;
        
        if (relativeX > 0 && relativeX < canvas.width) {
            paddle.x = relativeX - paddle.width / 2;
        }
    }

    canvas.addEventListener('mousemove', (e) => {
        const rect = canvas.getBoundingClientRect();
        const relativeX = e.clientX - rect.left;
        if (relativeX > 0 && relativeX < canvas.width) {
            paddle.x = relativeX - paddle.width / 2;
        }
    });

    function showMessage(element) {
        element.style.opacity = 1;
        setTimeout(() => { element.style.opacity = 0; }, 2000);
    }

    function showFloatingScore(text, color) {
        const el = document.createElement('div');
        el.className = 'score-float';
        el.innerText = text;
        el.style.color = color;
        const rect = canvas.getBoundingClientRect();
        const leftPos = rect.left + paddle.x + paddle.width/2;
        const bottomPos = rect.height - (canvas.height - paddle.height - BOTTOM_OFFSET) + 50;

        el.style.left = leftPos + 'px';
        el.style.bottom = bottomPos + 'px';
        
        document.body.appendChild(el); 
        setTimeout(() => el.remove(), 1000);
    }

    function update() {
        if (!isRunning) return;
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        drawBricks();
        drawPaddle();

        for (let i = balls.length - 1; i >= 0; i--) {
            if (balls[i]) updateBall(balls[i], i);
        }

        if (balls.length === 0 && !isGameOver && !isLevelComplete) gameOver();

        if (rightPressed && paddle.x < canvas.width - paddle.width) paddle.x += 7;
        else if (leftPressed && paddle.x > 0) paddle.x -= 7;

        if(paddle.x < 0) paddle.x = 0;
        if(paddle.x + paddle.width > canvas.width) paddle.x = canvas.width - paddle.width;

        if (!isGameOver && !isLevelComplete) animationId = requestAnimationFrame(update);
    }

    function updateBall(ball, index) {
        drawBall(ball);
        const levelChanged = collisionDetection(ball);
        if (levelChanged) return;

        if (ball.x + ball.dx > canvas.width - ball.radius || ball.x + ball.dx < ball.radius) {
            ball.dx = -ball.dx;
            if(ball.isFire) ball.isFire = false; 
        }

        if (ball.y + ball.dy < ball.radius) {
            ball.dy = -ball.dy;
            if(ball.isFire) ball.isFire = false; 
        } 
        else if (ball.y + ball.dy > canvas.height - ball.radius) {
            balls.splice(index, 1);
            return;
        }

        if (ball.y + ball.dy > canvas.height - paddle.height - BOTTOM_OFFSET - ball.radius &&
            ball.y < canvas.height - BOTTOM_OFFSET + paddle.height) {
            
            if (ball.x > paddle.x && ball.x < paddle.x + paddle.width) {
                if(ball.isFire) ball.isFire = false;

                const hits = ball.turnHits.length;
                if (hits === 1) {
                    score -= 1; if (score < 0) score = 0;
                    showFloatingScore("-1", "red");
                    
                    const hit = ball.turnHits[0];
                    if (bricks[hit.c] && bricks[hit.c][hit.r]) bricks[hit.c][hit.r].status = 1;
                    addPenaltyBrick(hit.c, hit.r);
                    
                } else if (hits >= 2) {
                    const points = hits * 2;
                    score += points;
                    showFloatingScore(`+${points}`, "#2ecc71");
                }
                
                scoreText.innerText = `Ø§Ù„Ù†Ù‚Ø§Ø·: ${score}`;
                ball.turnHits = [];

                let collidePoint = ball.x - (paddle.x + paddle.width / 2);
                collidePoint = collidePoint / (paddle.width / 2);
                let angle = collidePoint * (Math.PI / 3);
                
                let currentSpeed = Math.sqrt(ball.dx*ball.dx + ball.dy*ball.dy);
                if (currentSpeed < ball.speed) currentSpeed = ball.speed;
                currentSpeed += 0.1;

                ball.dx = currentSpeed * Math.sin(angle);
                ball.dy = -currentSpeed * Math.cos(angle);
                ball.speed = currentSpeed; 
            }
        }
        ball.x += ball.dx;
        ball.y += ball.dy;
    }

    function collisionDetection(ball) {
        let activeBricksCount = 0;
        for (let c = 0; c < brickProps.columnCount; c++) {
            for (let r = 0; r < brickProps.rowCount; r++) {
                const b = bricks[c][r];
                if (b.status === 1) {
                    activeBricksCount++;
                    if (ball.x > b.x && ball.x < b.x + brickProps.width &&
                        ball.y > b.y && ball.y < b.y + brickProps.height) {
                        
                        b.status = 0;
                        ball.turnHits.push({c: c, r: r});

                        if (b.isFire) { ball.isFire = true; showMessage(fireMessage); }
                        if (b.isMulti) {
                            showMessage(multiMessage);
                            balls.push(createBall(
                                b.x + brickProps.width/2, b.y + brickProps.height/2, 
                                ball.speed * (Math.random() > 0.5 ? 1 : -1), ball.speed, ball.speed
                            ));
                        }
                        if (!ball.isFire) ball.dy = -ball.dy;
                    }
                }
            }
        }
        if (activeBricksCount === 0) {
            levelComplete();
            return true;
        }
        return false;
    }

    function addPenaltyBrick(excludeC, excludeR) {
        let emptyBricks = [];
        for(let c=0; c<brickProps.columnCount; c++) {
            for(let r=0; r<brickProps.rowCount; r++) {
                if (bricks[c][r].status === 0 && (c !== excludeC || r !== excludeR)) {
                    emptyBricks.push({c, r});
                }
            }
        }
        if (emptyBricks.length > 0) {
            const p = emptyBricks[Math.floor(Math.random() * emptyBricks.length)];
            bricks[p.c][p.r].status = 1;
            applyRandomPowerUp(bricks[p.c][p.r]);
        } else {
            const newRowIndex = brickProps.rowCount;
            brickProps.rowCount++;
            for (let c = 0; c < brickProps.columnCount; c++) {
                if (!bricks[c]) bricks[c] = [];
                bricks[c][newRowIndex] = {
                    x: 0, y: 0, status: 0, color: brickProps.colors[newRowIndex % brickProps.colors.length], isFire: false, isMulti: false
                };
                applyRandomPowerUp(bricks[c][newRowIndex]);
            }
            const randomCol = Math.floor(Math.random() * brickProps.columnCount);
            bricks[randomCol][newRowIndex].status = 1;
        }
    }

    function applyRandomPowerUp(brick) {
        const rand = Math.random();
        if (rand < 0.1) { brick.isFire = true; brick.color = '#FFD700'; }
        else if (rand < 0.2) { brick.isMulti = true; brick.color = '#00FFFF'; }
    }

    function levelComplete() {
        isRunning = false;
        isLevelComplete = true;
        menu.classList.add('success-theme');
        menuTitle.innerText = "Ø£Ø­Ø³Ù†Øª!";
        menuDesc.innerHTML = `Ø£ÙƒÙ…Ù„Øª Ø§Ù„Ù…Ø³ØªÙˆÙ‰ ${level}<br>Ù†Ù‚Ø§Ø·Ùƒ Ø§Ù„Ø­Ø§Ù„ÙŠØ©: <span style="color:#2ecc71">${score}</span>`;
        startBtn.innerHTML = "<span>â©</span> Ø§Ù„Ù…Ø³ØªÙˆÙ‰ Ø§Ù„ØªØ§Ù„ÙŠ";
        menu.classList.remove('hidden');
        menu.style.display = 'block';
    }

    function handleMenuClick() {
        if (isGameOver) startGame();
        else if (isLevelComplete) nextLevel();
        else startGame();
    }

    function nextLevel() {
        level++;
        initBricks();
        levelText.innerText = `Ø§Ù„Ù…Ø³ØªÙˆÙ‰: ${level}`;
        resetGameKeepScore();
        menu.classList.remove('success-theme');
        menu.classList.add('hidden');
        menu.style.display = 'none';
        isLevelComplete = false;
        isRunning = true;
        update();
    }

    function drawBall(ball) {
        ctx.beginPath();
        ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2);
        if (ball.isFire) {
            ctx.fillStyle = '#ff4500'; ctx.shadowBlur = 15; ctx.shadowColor = "red";
        } else {
            ctx.fillStyle = ball.color; ctx.shadowBlur = 0;
        }
        ctx.fill(); ctx.shadowBlur = 0; ctx.closePath();
    }

    function drawPaddle() {
        ctx.beginPath();
        ctx.rect(paddle.x, canvas.height - paddle.height - BOTTOM_OFFSET, paddle.width, paddle.height);
        ctx.fillStyle = paddle.color;
        ctx.fill();
        ctx.strokeStyle = "#fff";
        ctx.stroke();
        ctx.closePath();
    }

    function drawBricks() {
        for (let c = 0; c < brickProps.columnCount; c++) {
            for (let r = 0; r < brickProps.rowCount; r++) {
                if (bricks[c][r].status === 1) {
                    const brickX = (c * (brickProps.width + brickProps.padding)) + brickProps.padding;
                    const brickY = (r * (brickProps.height + brickProps.padding)) + brickProps.offsetTop;
                    bricks[c][r].x = brickX;
                    bricks[c][r].y = brickY;
                    ctx.beginPath();
                    ctx.rect(brickX, brickY, brickProps.width, brickProps.height);
                    if (bricks[c][r].isFire) {
                        ctx.fillStyle = '#FFD700'; ctx.strokeStyle = '#fff'; ctx.lineWidth = 2; ctx.stroke();
                    } else if (bricks[c][r].isMulti) {
                        ctx.fillStyle = '#00FFFF'; ctx.strokeStyle = '#000'; ctx.lineWidth = 2; ctx.stroke();
                    } else {
                        ctx.fillStyle = bricks[c][r].color; ctx.lineWidth = 0;
                    }
                    ctx.fill(); ctx.closePath();
                }
            }
        }
    }

    function resetGameKeepScore() {
        balls = [];
        let startSpeed = 5 + (level * 0.5);
        balls.push(createBall(canvas.width / 2, canvas.height / 2, startSpeed * (Math.random() * 0.8 - 0.4), startSpeed, startSpeed));
        resetPaddle();
    }

    function resetPaddle() {
        paddle.width = canvas.width * 0.25;
        if (paddle.width < 80) paddle.width = 80;
        paddle.x = (canvas.width - paddle.width) / 2;
    }

    function gameOver() {
        isGameOver = true;
        isRunning = false;
        menu.classList.remove('success-theme');
        menuTitle.innerText = "Ø§Ù†ØªÙ‡Øª Ø§Ù„Ù„Ø¹Ø¨Ø©!";
        menuDesc.innerHTML = `Ø­ØµÙ„Øª Ø¹Ù„Ù‰ ${score} Ù†Ù‚Ø·Ø©.<br>ÙˆØµÙ„Øª Ù„Ù„Ù…Ø³ØªÙˆÙ‰ ${level}`;
        startBtn.innerHTML = "<span>ğŸ”„</span> Ø£Ø¹Ø¯ Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø©";
        menu.classList.remove('hidden');
        menu.style.display = 'block';
    }

    function startGame() {
        score = 0; level = 1;
        scoreText.innerText = "Ø§Ù„Ù†Ù‚Ø§Ø·: 0"; levelText.innerText = "Ø§Ù„Ù…Ø³ØªÙˆÙ‰: 1";
        isGameOver = false; isLevelComplete = false; isRunning = true;
        menu.classList.remove('success-theme');
        menu.classList.add('hidden');
        menu.style.display = 'none';
        initBricks();
        resetGameKeepScore();
        update();
    }
    
    window.addEventListener('load', checkStandaloneMode);
    window.addEventListener('resize', resizeCanvas);
    window.onload = resizeCanvas;
    resizeCanvas();
</script>
</body>
</html>


