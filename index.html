<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Ù„Ø¹Ø¨Ø© ÙƒØ³Ø± Ø§Ù„Ø·ÙˆØ¨ - Ø§Ù„ÙƒØ±Ø§Øª Ø§Ù„Ù…ØªØ¹Ø¯Ø¯Ø©</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Tajawal:wght@400;700&display=swap');

        body {
            margin: 0;
            padding: 0;
            background-color: #1a1a2e;
            color: white;
            font-family: 'Tajawal', sans-serif;
            overflow: hidden;
            touch-action: none;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
        }

        #gameContainer {
            position: relative;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
            border: 2px solid #444;
            background: #16213e;
        }

        canvas {
            display: block;
            background-color: #0f3460;
        }

        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 10px;
            box-sizing: border-box;
        }

        .score-board {
            font-size: 20px;
            font-weight: bold;
            text-shadow: 2px 2px 4px #000;
            display: flex;
            justify-content: space-between;
            width: 100%;
        }

        #menu {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.95);
            padding: 25px;
            border-radius: 15px;
            text-align: center;
            pointer-events: auto;
            border: 2px solid #e94560;
            min-width: 280px;
            z-index: 10;
        }

        h1 {
            margin: 0 0 10px 0;
            color: #e94560;
        }

        p {
            margin: 5px 0 20px 0;
            font-size: 15px;
            color: #ccc;
            line-height: 1.6;
        }

        button {
            background: #e94560;
            color: white;
            border: none;
            padding: 12px 30px;
            font-size: 18px;
            border-radius: 5px;
            cursor: pointer;
            font-family: 'Tajawal', sans-serif;
            transition: transform 0.1s;
            margin-top: 10px;
        }

        button:active {
            transform: scale(0.95);
        }

        .hidden {
            display: none !important;
        }

        /* ØªÙ†Ø³ÙŠÙ‚ Ø®Ø§Øµ Ù„Ù„Ù†Ø§ÙØ°Ø© Ø§Ù„Ø®Ø¶Ø±Ø§Ø¡ Ø¹Ù†Ø¯ Ø§Ù„ÙÙˆØ² */
        #menu.success-theme {
            border-color: #2ecc71 !important;
        }
        #menu.success-theme h1 {
            color: #2ecc71 !important;
        }
        #menu.success-theme button {
            background: #2ecc71 !important;
        }

        /* Ø±Ø³Ø§Ù„Ø© Ù…Ù†Ø¨Ø«Ù‚Ø© */
        .message-popup {
            position: absolute;
            top: 30%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 24px;
            font-weight: bold;
            text-shadow: 0 0 10px #000;
            opacity: 0;
            transition: opacity 0.5s;
            pointer-events: none;
            width: 100%;
            text-align: center;
        }
        
        /* ØªØ£Ø«ÙŠØ±Ø§Øª Ø§Ù„Ø·ÙˆØ¨ Ø§Ù„Ù…ÙƒØ³ÙˆØ± (Ø§Ø®ØªÙŠØ§Ø±ÙŠ) */
        .score-float {
            position: absolute;
            color: #fff;
            font-weight: bold;
            font-size: 20px;
            pointer-events: none;
            animation: floatUp 1s ease-out forwards;
        }

        @keyframes floatUp {
            0% { transform: translateY(0); opacity: 1; }
            100% { transform: translateY(-30px); opacity: 0; }
        }
    </style>
</head>
<body>

    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>
        <div id="fireMessage" class="message-popup" style="color: #f39c12; text-shadow: 0 0 10px red;">ğŸ”¥ ÙƒØ±Ø© Ù†Ø§Ø±ÙŠØ©! ğŸ”¥</div>
        <div id="multiMessage" class="message-popup" style="color: #00FFFF; text-shadow: 0 0 10px blue; top: 40%;">âš½ ÙƒØ±Ø© Ø¥Ø¶Ø§ÙÙŠØ©! âš½</div>
        
        <!-- ÙˆØ§Ø¬Ù‡Ø© Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù… (Ø§Ù„Ù†Ù‚Ø§Ø·) -->
        <div id="ui-layer">
            <div class="score-board">
                <span id="scoreText">Ø§Ù„Ù†Ù‚Ø§Ø·: 0</span>
                <span id="levelText">Ø§Ù„Ù…Ø³ØªÙˆÙ‰: 1</span>
            </div>
            <div id="scoreEffectContainer"></div>
        </div>

        <!-- Ø§Ù„Ù‚Ø§Ø¦Ù…Ø© -->
        <div id="menu">
            <h1 id="menuTitle">Ù„Ø¹Ø¨Ø© ÙƒØ³Ø± Ø§Ù„Ø·ÙˆØ¨</h1>
            <p id="menuDesc" style="color: #fff;">
                <span style="color:#e94560; font-weight:bold">Ø§Ù„Ù‚ÙˆØ§Ø¹Ø¯ Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø©:</span><br>
                1. ÙƒØ³Ø± Ø·ÙˆØ¨Ø© ÙˆØ§Ø­Ø¯Ø© = <span style="color:red">-1 Ù†Ù‚Ø·Ø©</span> (ÙˆØ¹ÙˆØ¯Ø© Ø§Ù„Ø·ÙˆØ¨Ø©!)<br>
                2. ÙƒØ³Ø± Ø·ÙˆØ¨ØªÙŠÙ† Ø£Ùˆ Ø£ÙƒØ«Ø± = <span style="color:#2ecc71">Ø¹Ø¯Ø¯ Ø§Ù„Ø·ÙˆØ¨ Ã— 2</span> Ù†Ù‚Ø§Ø·<br>
                3. Ø§Ù„Ø·ÙˆØ¨ Ø§Ù„Ø°Ù‡Ø¨ÙŠ = Ù†Ø§Ø± ğŸ”¥ | Ø§Ù„Ø³Ù…Ø§ÙˆÙŠ = ÙƒØ±Ø© âš½
            </p>
            <button id="startBtn" onclick="handleMenuClick()">Ø§Ø¨Ø¯Ø£ Ø§Ù„Ù„Ø¹Ø¨</button>
        </div>
    </div>

<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const menu = document.getElementById('menu');
    const menuTitle = document.getElementById('menuTitle');
    const menuDesc = document.getElementById('menuDesc');
    const startBtn = document.getElementById('startBtn');
    const scoreText = document.getElementById('scoreText');
    const levelText = document.getElementById('levelText');
    const fireMessage = document.getElementById('fireMessage');
    const multiMessage = document.getElementById('multiMessage');

    // Ù…ØªØºÙŠØ±Ø§Øª Ø§Ù„Ù„Ø¹Ø¨Ø©
    let animationId;
    let score = 0;
    let level = 1;
    let isGameOver = false;
    let isLevelComplete = false; // Ø­Ø§Ù„Ø© Ø¬Ø¯ÙŠØ¯Ø©: Ø§ÙƒØªÙ…Ø§Ù„ Ø§Ù„Ù…Ø³ØªÙˆÙ‰
    let isRunning = false;
    
    // Ù…ØµÙÙˆÙØ© Ø§Ù„ÙƒØ±Ø§Øª (Ø¨Ø¯Ù„Ø§Ù‹ Ù…Ù† ÙƒØ±Ø© ÙˆØ§Ø­Ø¯Ø©)
    let balls = [];

    // Ø®ØµØ§Ø¦Øµ Ø§Ù„Ø®Ø´Ø¨Ø©
    const paddle = {
        width: 100,
        height: 15,
        x: 0,
        color: '#00adb5',
        speed: 8
    };

    // Ø®ØµØ§Ø¦Øµ Ø§Ù„Ø·ÙˆØ¨
    const brickProps = {
        rowCount: 5,
        columnCount: 5,
        padding: 30,
        offsetTop: 60,
        height: 25,
        colors: ['#f39c12', '#e74c3c', '#9b59b6', '#3498db', '#2ecc71']
    };
    
    let bricks = [];

    // Ø¯Ø§Ù„Ø© Ø¥Ù†Ø´Ø§Ø¡ ÙƒØ±Ø© Ø¬Ø¯ÙŠØ¯Ø©
    function createBall(x, y, dx, dy, speed) {
        return {
            x: x, 
            y: y,
            dx: dx,
            dy: dy,
            radius: 8,
            speed: speed,
            color: '#e94560',
            isFire: false,
            turnHits: [] // Ø³Ø¬Ù„ Ø§Ù„Ø¶Ø±Ø¨Ø§Øª Ø§Ù„Ø®Ø§Øµ Ø¨Ù‡Ø°Ù‡ Ø§Ù„ÙƒØ±Ø©
        };
    }

    function resizeCanvas() {
        const maxWidth = 600;
        let width = window.innerWidth;
        let height = window.innerHeight;

        if (width > maxWidth) {
            width = maxWidth;
            height = window.innerHeight * 0.9;
        }

        canvas.width = width;
        canvas.height = height;

        if (!isRunning && !isLevelComplete) {
            initBricks(false);
            if(balls.length > 0) {
                balls.forEach(drawBall);
            }
            drawBricks();
            drawPaddle();
        } else if (isLevelComplete) {
            // Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„Ø±Ø³Ù… ÙÙŠ Ø§Ù„Ø®Ù„ÙÙŠØ© Ø£Ø«Ù†Ø§Ø¡ Ø§Ù„ØªÙˆÙ‚Ù
            drawBricks();
            drawPaddle();
        }
    }

    function initBricks(reset = true) {
        let currentPadding = 34 - (level * 4);
        if (currentPadding < 5) currentPadding = 5;
        brickProps.padding = currentPadding;

        if (reset) {
            bricks = [];
            brickProps.rowCount = 5 + (level - 1);
        }
        
        const brickWidth = (canvas.width - (brickProps.padding * 2)) / brickProps.columnCount - brickProps.padding;
        brickProps.width = brickWidth;

        if (reset) {
            for (let c = 0; c < brickProps.columnCount; c++) {
                bricks[c] = [];
            }
            for (let r = 0; r < brickProps.rowCount; r++) {
                for (let c = 0; c < brickProps.columnCount; c++) {
                    createBrickAt(c, r);
                }
            }
        }
    }

    function createBrickAt(c, r) {
        // Ø§Ø­ØªÙ…Ø§Ù„Ø§Øª Ø§Ù„Ù…ÙŠØ²Ø§Øª
        const rand = Math.random();
        let isFire = false;
        let isMulti = false;
        let color = brickProps.colors[r % brickProps.colors.length];

        if (rand < 0.1) {
            isFire = true;
            color = '#FFD700';
        } else if (rand < 0.2) {
            isMulti = true;
            color = '#00FFFF';
        }

        bricks[c][r] = {
            x: 0,
            y: 0,
            status: 1,
            color: color,
            isFire: isFire,
            isMulti: isMulti
        };
    }

    // Ø§Ù„ØªØ­ÙƒÙ…
    let rightPressed = false;
    let leftPressed = false;

    document.addEventListener('keydown', keyDownHandler);
    document.addEventListener('keyup', keyUpHandler);
    document.addEventListener('mousemove', mouseMoveHandler);
    canvas.addEventListener('touchmove', touchMoveHandler, {passive: false});

    function keyDownHandler(e) {
        if (e.key === 'Right' || e.key === 'ArrowRight') rightPressed = true;
        else if (e.key === 'Left' || e.key === 'ArrowLeft') leftPressed = true;
    }
    function keyUpHandler(e) {
        if (e.key === 'Right' || e.key === 'ArrowRight') rightPressed = false;
        else if (e.key === 'Left' || e.key === 'ArrowLeft') leftPressed = false;
    }
    function mouseMoveHandler(e) {
        const relativeX = e.clientX - canvas.getBoundingClientRect().left;
        if (relativeX > 0 && relativeX < canvas.width) {
            paddle.x = relativeX - paddle.width / 2;
        }
    }
    function touchMoveHandler(e) {
        e.preventDefault();
        const relativeX = e.touches[0].clientX - canvas.getBoundingClientRect().left;
        if (relativeX > 0 && relativeX < canvas.width) {
            paddle.x = relativeX - paddle.width / 2;
        }
    }

    function showMessage(element) {
        element.style.opacity = 1;
        setTimeout(() => {
            element.style.opacity = 0;
        }, 2000);
    }

    // Ø¯Ø§Ù„Ø© Ø¬Ø¯ÙŠØ¯Ø© Ù„Ø¥Ø¸Ù‡Ø§Ø± ØªØ£Ø«ÙŠØ± Ø§Ù„Ù†Ù‚Ø§Ø· Ø§Ù„Ø¹Ø§Ø¦Ù…Ø©
    function showFloatingScore(text, color) {
        const el = document.createElement('div');
        el.className = 'score-float';
        el.innerText = text;
        el.style.color = color;
        // Ù…ÙˆÙ‚Ø¹ ØªÙ‚Ø±ÙŠØ¨ÙŠ ÙÙˆÙ‚ Ø§Ù„Ø®Ø´Ø¨Ø©
        el.style.left = (paddle.x + paddle.width/2 + canvas.getBoundingClientRect().left) + 'px';
        el.style.bottom = '100px'; 
        // Ø¨Ù…Ø§ Ø£Ù† ui-layer ÙÙˆÙ‚ Ø§Ù„ÙƒØ§Ù†ÙØ§Ø³ØŒ Ù†Ø¶Ø¨Ø· Ø§Ù„Ù…ÙˆÙ‚Ø¹ Ø¨Ø§Ù„Ù†Ø³Ø¨Ø© Ù„Ù‡
        el.style.left = (paddle.x + paddle.width/2) + 'px';
        el.style.bottom = '50px';
        
        document.getElementById('ui-layer').appendChild(el);
        setTimeout(() => el.remove(), 1000);
    }

    function update() {
        if (!isRunning) return;

        ctx.clearRect(0, 0, canvas.width, canvas.height);

        drawBricks();
        drawPaddle();

        for (let i = balls.length - 1; i >= 0; i--) {
            if (balls[i]) {
                updateBall(balls[i], i);
            }
        }

        if (balls.length === 0 && !isGameOver && !isLevelComplete) {
            gameOver();
        }

        if (rightPressed && paddle.x < canvas.width - paddle.width) paddle.x += 7;
        else if (leftPressed && paddle.x > 0) paddle.x -= 7;

        if(paddle.x < 0) paddle.x = 0;
        if(paddle.x + paddle.width > canvas.width) paddle.x = canvas.width - paddle.width;

        if (!isGameOver && !isLevelComplete) {
            animationId = requestAnimationFrame(update);
        }
    }

    function updateBall(ball, index) {
        drawBall(ball);
        
        const levelChanged = collisionDetection(ball);
        if (levelChanged) return;

        if (ball.x + ball.dx > canvas.width - ball.radius || ball.x + ball.dx < ball.radius) {
            ball.dx = -ball.dx;
            if(ball.isFire) ball.isFire = false; 
        }

        if (ball.y + ball.dy < ball.radius) {
            ball.dy = -ball.dy;
            if(ball.isFire) ball.isFire = false; 
        } 
        else if (ball.y + ball.dy > canvas.height - ball.radius) {
            balls.splice(index, 1);
            return;
        }

        if (ball.y + ball.dy > canvas.height - paddle.height - 10 - ball.radius &&
            ball.y < canvas.height - 10) {
            
            if (ball.x > paddle.x && ball.x < paddle.x + paddle.width) {
                
                if(ball.isFire) ball.isFire = false;

                // === Ù†Ø¸Ø§Ù… Ø§Ù„Ù†Ù‚Ø§Ø· Ø§Ù„Ø¬Ø¯ÙŠØ¯ ===
                const hits = ball.turnHits.length;
                
                if (hits === 1) {
                    // 1. Ø®ØµÙ… Ø¯Ø±Ø¬Ø© ÙˆØ§Ø­Ø¯Ø©
                    score -= 1;
                    if (score < 0) score = 0;
                    showFloatingScore("-1", "red");
                    
                    // 2. Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„Ø·ÙˆØ¨Ø© (Ø§Ù„Ø¹Ù‚Ø§Ø¨ Ø§Ù„Ù‚Ø¯ÙŠÙ… Ù…Ø³ØªÙ…Ø±)
                    const hit = ball.turnHits[0];
                    if (bricks[hit.c] && bricks[hit.c][hit.r]) {
                        bricks[hit.c][hit.r].status = 1;
                    }
                    // 3. Ø¥Ø¶Ø§ÙØ© Ø·ÙˆØ¨Ø© Ø¹Ù‚Ø§Ø¨ Ø¥Ø¶Ø§ÙÙŠØ©
                    addPenaltyBrick(hit.c, hit.r);
                    
                } else if (hits >= 2) {
                    // Ø­Ø³Ø§Ø¨ Ø§Ù„Ù†Ù‚Ø§Ø·: Ø¹Ø¯Ø¯ Ø§Ù„Ø·ÙˆØ¨ * 2
                    const points = hits * 2;
                    score += points;
                    showFloatingScore(`+${points}`, "#2ecc71");
                }
                
                // ØªØ­Ø¯ÙŠØ« Ø§Ù„Ù†Øµ
                scoreText.innerText = `Ø§Ù„Ù†Ù‚Ø§Ø·: ${score}`;

                // ØªØµÙÙŠØ± Ø§Ù„Ø³Ø¬Ù„
                ball.turnHits = [];
                // ==========================

                let collidePoint = ball.x - (paddle.x + paddle.width / 2);
                collidePoint = collidePoint / (paddle.width / 2);
                let angle = collidePoint * (Math.PI / 3);
                
                let currentSpeed = Math.sqrt(ball.dx*ball.dx + ball.dy*ball.dy);
                if (currentSpeed < ball.speed) currentSpeed = ball.speed;
                currentSpeed += 0.1;

                ball.dx = currentSpeed * Math.sin(angle);
                ball.dy = -currentSpeed * Math.cos(angle);
                ball.speed = currentSpeed; 
            }
        }

        ball.x += ball.dx;
        ball.y += ball.dy;
    }

    function collisionDetection(ball) {
        let activeBricksCount = 0;

        for (let c = 0; c < brickProps.columnCount; c++) {
            for (let r = 0; r < brickProps.rowCount; r++) {
                const b = bricks[c][r];
                if (b.status === 1) {
                    activeBricksCount++;
                    if (
                        ball.x > b.x &&
                        ball.x < b.x + brickProps.width &&
                        ball.y > b.y &&
                        ball.y < b.y + brickProps.height
                    ) {
                        b.status = 0;
                        // Ù…Ù„Ø§Ø­Ø¸Ø©: Ø£Ù„ØºÙŠÙ†Ø§ Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ù†Ù‚Ø§Ø· Ù‡Ù†Ø§
                        
                        ball.turnHits.push({c: c, r: r});

                        if (b.isFire) {
                            ball.isFire = true;
                            showMessage(fireMessage);
                        }

                        if (b.isMulti) {
                            showMessage(multiMessage);
                            balls.push(createBall(
                                b.x + brickProps.width/2, 
                                b.y + brickProps.height/2, 
                                ball.speed * (Math.random() > 0.5 ? 1 : -1),
                                ball.speed, 
                                ball.speed
                            ));
                        }

                        if (!ball.isFire) {
                            ball.dy = -ball.dy;
                        }
                    }
                }
            }
        }

        if (activeBricksCount === 0) {
            levelComplete(); // ØªØºÙŠÙŠØ±: Ø§Ø³ØªØ¯Ø¹Ø§Ø¡ Ø¯Ø§Ù„Ø© Ø§ÙƒØªÙ…Ø§Ù„ Ø§Ù„Ù…Ø³ØªÙˆÙ‰ Ø¨Ø¯Ù„Ø§Ù‹ Ù…Ù† Ø§Ù„Ø§Ù†ØªÙ‚Ø§Ù„ Ø§Ù„Ù…Ø¨Ø§Ø´Ø±
            return true;
        }
        return false;
    }

    function addPenaltyBrick(excludeC, excludeR) {
        let emptyBricks = [];
        for(let c=0; c<brickProps.columnCount; c++) {
            for(let r=0; r<brickProps.rowCount; r++) {
                if (bricks[c][r].status === 0 && (c !== excludeC || r !== excludeR)) {
                    emptyBricks.push({c, r});
                }
            }
        }
        
        if (emptyBricks.length > 0) {
            const p = emptyBricks[Math.floor(Math.random() * emptyBricks.length)];
            bricks[p.c][p.r].status = 1;
            applyRandomPowerUp(bricks[p.c][p.r]);
        } else {
            const newRowIndex = brickProps.rowCount;
            brickProps.rowCount++;
            
            for (let c = 0; c < brickProps.columnCount; c++) {
                if (!bricks[c]) bricks[c] = [];
                bricks[c][newRowIndex] = {
                    x: 0, y: 0, status: 0, color: brickProps.colors[newRowIndex % brickProps.colors.length], isFire: false, isMulti: false
                };
                applyRandomPowerUp(bricks[c][newRowIndex]);
            }
            const randomCol = Math.floor(Math.random() * brickProps.columnCount);
            bricks[randomCol][newRowIndex].status = 1;
        }
    }

    function applyRandomPowerUp(brick) {
        const rand = Math.random();
        if (rand < 0.1) {
            brick.isFire = true;
            brick.color = '#FFD700';
        } else if (rand < 0.2) {
            brick.isMulti = true;
            brick.color = '#00FFFF';
        }
    }

    // Ø¯Ø§Ù„Ø© Ø¬Ø¯ÙŠØ¯Ø©: ØªØ¹Ø±Ø¶ Ø´Ø§Ø´Ø© Ø§ÙƒØªÙ…Ø§Ù„ Ø§Ù„Ù…Ø³ØªÙˆÙ‰
    function levelComplete() {
        isRunning = false;
        isLevelComplete = true;
        
        // ØªÙØ¹ÙŠÙ„ Ø§Ù„Ø«ÙŠÙ… Ø§Ù„Ø£Ø®Ø¶Ø±
        menu.classList.add('success-theme');

        menuTitle.innerText = "Ø£Ø­Ø³Ù†Øª!";
        menuDesc.innerHTML = `Ø£ÙƒÙ…Ù„Øª Ø§Ù„Ù…Ø³ØªÙˆÙ‰ ${level}<br>Ù†Ù‚Ø§Ø·Ùƒ Ø§Ù„Ø­Ø§Ù„ÙŠØ©: <span style="color:#2ecc71">${score}</span>`;
        startBtn.innerText = "Ø§Ù„Ù…Ø³ØªÙˆÙ‰ Ø§Ù„ØªØ§Ù„ÙŠ";
        
        menu.classList.remove('hidden');
        menu.style.display = 'block';
    }

    // Ø¯Ø§Ù„Ø© Ø§Ù„Ø§Ù†ØªÙ‚Ø§Ù„ Ø§Ù„ÙØ¹Ù„ÙŠ Ù„Ù„Ù…Ø³ØªÙˆÙ‰ Ø§Ù„ØªØ§Ù„ÙŠ (ØªÙØ³ØªØ¯Ø¹Ù‰ Ù…Ù† Ø§Ù„Ø²Ø±)
    function nextLevel() {
        level++;
        initBricks();
        levelText.innerText = `Ø§Ù„Ù…Ø³ØªÙˆÙ‰: ${level}`;
        resetGameKeepScore();
        
        // Ø¥Ø²Ø§Ù„Ø© Ø§Ù„Ø«ÙŠÙ… Ø§Ù„Ø£Ø®Ø¶Ø± ÙˆØ¥Ø®ÙØ§Ø¡ Ø§Ù„Ù‚Ø§Ø¦Ù…Ø©
        menu.classList.remove('success-theme');
        menu.classList.add('hidden');
        menu.style.display = 'none';
        isLevelComplete = false;
        isRunning = true;
        update();
    }

    function drawBall(ball) {
        ctx.beginPath();
        ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2);
        
        if (ball.isFire) {
            ctx.fillStyle = '#ff4500';
            ctx.shadowBlur = 15;
            ctx.shadowColor = "red";
        } else {
            ctx.fillStyle = ball.color;
            ctx.shadowBlur = 0;
        }
        
        ctx.fill();
        ctx.shadowBlur = 0;
        ctx.closePath();
    }

    function drawPaddle() {
        ctx.beginPath();
        ctx.rect(paddle.x, canvas.height - paddle.height - 10, paddle.width, paddle.height);
        ctx.fillStyle = paddle.color;
        ctx.fill();
        ctx.strokeStyle = "#fff";
        ctx.stroke();
        ctx.closePath();
    }

    function drawBricks() {
        for (let c = 0; c < brickProps.columnCount; c++) {
            for (let r = 0; r < brickProps.rowCount; r++) {
                if (bricks[c][r].status === 1) {
                    const brickX = (c * (brickProps.width + brickProps.padding)) + brickProps.padding;
                    const brickY = (r * (brickProps.height + brickProps.padding)) + brickProps.offsetTop;
                    bricks[c][r].x = brickX;
                    bricks[c][r].y = brickY;
                    
                    ctx.beginPath();
                    ctx.rect(brickX, brickY, brickProps.width, brickProps.height);
                    
                    if (bricks[c][r].isFire) {
                        ctx.fillStyle = '#FFD700';
                        ctx.strokeStyle = '#fff';
                        ctx.lineWidth = 2;
                        ctx.stroke();
                    } else if (bricks[c][r].isMulti) {
                        ctx.fillStyle = '#00FFFF';
                        ctx.strokeStyle = '#000';
                        ctx.lineWidth = 2;
                        ctx.stroke();
                    } else {
                        ctx.fillStyle = bricks[c][r].color;
                        ctx.lineWidth = 0;
                    }
                    
                    ctx.fill();
                    ctx.closePath();
                }
            }
        }
    }

    function resetGameKeepScore() {
        balls = [];
        let startSpeed = 5 + (level * 0.5);
        balls.push(createBall(
            canvas.width / 2, 
            canvas.height / 2, 
            startSpeed * (Math.random() * 0.8 - 0.4), 
            startSpeed, 
            startSpeed
        ));
        
        resetPaddle();
    }

    function resetPaddle() {
        paddle.width = canvas.width * 0.25;
        if (paddle.width < 80) paddle.width = 80;
        paddle.x = (canvas.width - paddle.width) / 2;
    }

    function gameOver() {
        isGameOver = true;
        isRunning = false;
        
        // Ø§Ù„ØªØ£ÙƒØ¯ Ù…Ù† Ø¥Ø²Ø§Ù„Ø© Ø§Ù„Ø«ÙŠÙ… Ø§Ù„Ø£Ø®Ø¶Ø± Ù„ØªØ¹ÙˆØ¯ Ø­Ù…Ø±Ø§Ø¡ Ø¹Ù†Ø¯ Ø§Ù„Ø®Ø³Ø§Ø±Ø©
        menu.classList.remove('success-theme');

        menuTitle.innerText = "Ø§Ù†ØªÙ‡Øª Ø§Ù„Ù„Ø¹Ø¨Ø©!";
        menuDesc.innerHTML = `Ø­ØµÙ„Øª Ø¹Ù„Ù‰ ${score} Ù†Ù‚Ø·Ø©.<br>ÙˆØµÙ„Øª Ù„Ù„Ù…Ø³ØªÙˆÙ‰ ${level}`;
        startBtn.innerText = "Ø£Ø¹Ø¯ Ø§Ù„Ù…Ø­Ø§ÙˆÙ„Ø©";
        menu.classList.remove('hidden');
        menu.style.display = 'block';
    }
    
    // Ø¯Ø§Ù„Ø© Ù…ÙˆØ­Ø¯Ø© Ù„Ù„ØªØ¹Ø§Ù…Ù„ Ù…Ø¹ Ø²Ø± Ø§Ù„Ù‚Ø§Ø¦Ù…Ø©
    function handleMenuClick() {
        if (isGameOver) {
            startGame();
        } else if (isLevelComplete) {
            nextLevel();
        } else {
            // Ø¨Ø¯Ø§ÙŠØ© Ø§Ù„Ù„Ø¹Ø¨Ø© Ù„Ø£ÙˆÙ„ Ù…Ø±Ø©
            startGame();
        }
    }

    function startGame() {
        score = 0;
        level = 1;
        scoreText.innerText = "Ø§Ù„Ù†Ù‚Ø§Ø·: 0";
        levelText.innerText = "Ø§Ù„Ù…Ø³ØªÙˆÙ‰: 1";
        isGameOver = false;
        isLevelComplete = false;
        isRunning = true;
        
        // Ø¥Ø²Ø§Ù„Ø© Ø§Ù„Ø«ÙŠÙ… Ø§Ù„Ø£Ø®Ø¶Ø± Ø¹Ù†Ø¯ Ø¨Ø¯Ø¡ Ù„Ø¹Ø¨Ø© Ø¬Ø¯ÙŠØ¯Ø©
        menu.classList.remove('success-theme');
        menu.classList.add('hidden');
        menu.style.display = 'none';

        initBricks();
        resetGameKeepScore();
        update();
    }
    
    window.addEventListener('resize', resizeCanvas);
    window.onload = function() { resizeCanvas(); };
    resizeCanvas();

</script>
</body>
</html>
